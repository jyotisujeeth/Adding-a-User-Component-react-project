{"version":3,"names":["VALID_OBJECT_CALLEES","VALID_IDENTIFIER_CALLEES","INVALID_METHODS","isValidObjectCallee","val","includes","isValidIdentifierCallee","isInvalidMethod","evaluateTruthy","res","evaluate","confident","value","deopt","path","state","deoptPath","Globals","Map","undefined","Infinity","NaN","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","key","computed","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","global","args","map","apply","raw","str","i","cooked","expr","String"],"sources":["../../src/path/evaluation.ts"],"sourcesContent":["import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n"],"mappings":"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